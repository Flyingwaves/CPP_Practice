### 练习 4.1
求值结果是 105
### 练习 4.2
```
(a) *(vec.begin())
(b) (*(vec.begin())) + 1
```
### 练习 4.3
不可以。不同编译器优化结果可能导致求值顺序不一样，出现无法解决的错误。
### 练习 4.4
```
((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2)
= 16 + 75 + 0
= 91
```
### 练习 4.5
(a) -90 + 4 = -86

(b) -30 + 12 = -18

(c) 210 % 5 = 0

(d) -210 % 4 = -2
### 练习 4.6
```
i % 2    //求余法
i & 0x1    //位运算法
```
### 练习 4.7
溢出：计算结果超越类型的表示范围
```
short a = 32767; a ++;       //a = -32768
short b = -32768; b = -b;    //b = -32768
unsigned c = 0; c --;        //c = 4294967295
```
### 练习 4.8
逻辑与：只有左侧为真，才对右侧求值判断

逻辑或：只有左侧为假，才对右侧求值判断

相等：没啥顺序，两边都要算
### 练习 4.9
首先看cp，非空指针，左侧为真

再看*cp，解引用为第一个元素，常量'H'，非0，右侧为真

所以if条件判断为真
### 练习 4.10
```
while(cin >> num && num != 42)
```
### 练习 4.11
```
a < b && b < c && c < d
```
### 练习 4.12
根据优先级，先判断`j < k`

若为假，转化为`i != false`，由于i不是布尔类型，进而转化为`i != 0`

若为真，转化为`i != true`，同理，可进一步变为`i != 1`
